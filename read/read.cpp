//this file is encoded with utf-8
//if you cannot see the chinese characters
//please open this file with editor supporting utf-8,and switch the encoding to utf-8
//visual studio code is recommended

//ubuntu pastebin竟然不支持markdown......qwq

//广告开始
//当读入量在1000000的级别时,读入往往是程序运行时间的瓶颈
//因此,我们需要一个快速可靠好写好读(还很骚)的读入优化。。
//这个读入优化是用fread实现的。。
//听说用mmap读更快,但是不好写,并且windows系统里用不了
//fread读大量字符(一百万以上)的效率特别高。。
//fread快读的主要思想是手写一个缓冲区,每一次从输入文件向缓冲区里读大量字符,然后再从缓冲区里读取字符
//linux环境下,速度约为scanf的10倍,getchar版快读的1.5倍
//可能觉得这点优化不算什么。。。但是。。
//昨天写一道题。。bzoj4196。。数据规模只有100000左右。。
//一开始tle。。把scanf改成fread快读就ac了。。
//时限10s,跑了9.8s。。
//所以有时候tle和ac之间只差了一个快读(逃)

//正文开始
char *p1,*p2,buffer[10000000];
//定义一个缓冲区buffer,和两个指针p1,p2
//p1指向缓冲区中当前访问到的位置,p2指向缓冲区中最后一个字符的位置+1
char gc() //重写getchar()
{
	char ch=0;
	if(p1!=p2) //若当前缓冲区中仍有剩余字符
	{
		ch=*p1; //读到的字符为p1指向的字符
		p1++; //缓冲区中当前访问到的位置+1
	}
	else //否则说明缓冲区没有剩余字符,再从输入文件中读10000000个字符到缓冲区当中,若输入文件中剩余不到10000000个字符,就全读进来
	{
		p1=buffer; //把p1重置到缓冲区的起始位置
		p2=buffer+fread(buffer,1,10000000,stdin); //fread返回读进来的字符个数,缓冲区最后一个字符的位置+1=起始位置+读进来的字符个数
		ch=*p1; //读到的字符为p1指向的元素
		p1++; //当前访问到的位置+1
	}
	return ch; //返回当前读到的元素
}
void read(int &x) //x为指向实参的引用,改变x就可以改变实参的值
{
	char ch=0; //定义一个初始值为0的字符变量ch
	int inv=0; //inv记录是否读到负号
	x=0; //将x置为0
	while(ch<'0'||ch>'9') //当ch不是数字时
	{
		ch=gc(); //继续读ch
		if(ch=='-') //如果读到负号
			inv=1; //将inv置为1
	}
	while(ch>='0'&&ch<='9') //当ch是数字时
	{
		x=(x*10)+ch-'0'; //x等于x乘10+新读进来的数字
		ch=gc(); //继续读ch
	}
	if(inv==1) //如果读到负号
		x=-x; //把x变成负数
}
//这样写就可以了。。。
//但是有巨佬觉得函数调用需要时间。。
//并且三目运算符(?:)也比if语句快。。
//再加上&&的短路特性(若&&前面的表达式为假,则跳过后面的表达式)
//还有赋值表达式的返回值即为所赋的值
//就有巨佬写出了宏(sang)定(xin)义(bing)版(kuang)的快读。。避免了函数调用的时间还包含了一系列的黑科技优化
#define gc() (p1==p2&&(p2=(p1=buffer)+fread(buffer,1,10000000,stdin),p1==p2)?EOF:*p1++)
//用一句话就代替了上面的gc()函数。。。
//在编译的时候,编译器会把所有的gc()都替换成(p1==p2&&(p2=(p1=buffer)+fread(buffer,1,1000000,stdin),p1==p2)?EOF:*p1++)
//所以就省掉了函数调用的时间。。
//如果不想理解的话可以直接背板子qwq
//首先,这条语句是一个三目运算符,如果"?"前面的条件为真,则返回":"前面的值,否则返回":"后面的值
//对于该语句,若条件为真,返回EOF(文件结束标志),否则返回*p1++
//*p1++代表的是先返回p1指向的字符(*p1),然后再把p1指向的位置+1(p1++)
//看一下前面的条件语句,如果p1!=p2,那么说明缓冲区仍有剩余字符,就直接返回p1指向的字符(*p1),然后再把p1指向的位置+1(p1++)
//同时基于&&的短路特性,前面的表达式为假,则直接跳过后面的表达式
//否则如果p1==p2,那么说明缓冲区已被读空,执行后面的语句,将p1重置为缓冲区的起始位置,p1=buffer的返回值即为buffer
//p2=缓冲区最后一个字符的位置+1=起始位置+读进来的字符个数
//若有多个语句用逗号连接,则它的返回值是最后一个语句的返回值
//因此&&后的语句的返回值为p1==p2
//如果这时候p1仍然等于p2,则说明读进来的字符个数为0,文件已经读到末尾,返回EOF
//否则返回p1指向的字符(*p1),然后再把p1指向的位置+1(p1++)
#define rc register char //register定义一个寄存器变量,访问速度比内存里的变量要快很多
//下面就是一个宏定义函数
//编译器在编译的时候,会把所有的read(某变量) 全部替换为里面的语句
//避免了调用函数的时间,只不过编译产生的程序会大一点。。
//为什么要在行末加反斜杠"\"? 因为行末的反斜杠起到连接多行的作用 \
就像这样qwq 虽然这一行的行首没有"//",但是因为上一行行末有反斜杠"\",所以这一行和上一行连在一起，仍然是注释
//行末的反斜杠也可以连接多行的宏定义
#define read(x) {  /* 因为这是一个宏定义函数,所以x可以看作实参 */ \
	rc ch=0,inv=0; \
	x=0; /* x初始化为0 */ \
	while(ch<'0'||ch>'9') /* ch不是数字字符 */ \
	{ \
		ch=='-'&&(inv=1); /*假如读到不是负号,前面的条件为假,直接短路,不再执行后面的语句,inv=1 (注意运算符优先级) */ \
		ch=gc(); /* 继续读ch */ \
	} \
	while(ch>='0'&&ch<='9') /* ch是数字字符 */ \
		x=(x<<1)+(x<<3)+(ch&15),ch=gc(); /* x<<1等效于x*2,x<<3等效于x*8,(x<<1)+(x<<3)等效于x*10,用了位运算所以更快(写的时候注意运算符优先级) */ \
	/* '0'的ascii码是48,48二进制的低4位是0000,也就是0,'9'的ascii码是57,二进制的低4位是1001,也就是9*/ \
	/* 因此,对于'0'-'9'的字符,取二进制的低4位,就是0-9的数字 */ \
	inv&&(x=-x); /* 若inv为0,则直接短路,跳过后面的语句,否则x=-x (注意运算符优先级) */ \
}

//----------------------我是分割线----------------------

//以a+b问题为例。。
#include<cstdio>
#define rc register char
#define gc() (p1==p2&&(p2=(p1=buffer)+fread(buffer,1,10000000,stdin),p1==p2)?EOF:*p1++)
#define read(x) \
{ \
	rc ch=0,inv=0; \
	x=0; \
	while(ch<'0'||ch>'9') \
	{ \
		ch=='-'&&(inv=1); \
		ch=gc(); \
	} \
	while(ch>='0'&&ch<='9') \
		x=(x<<1)+(x<<3)+(ch&15),ch=gc(); \
	inv&&(x=-x); \
}
char *p1,*p2,buffer[10000000];
int main()
{
	//使用fread快读时候,在本地是无法使用控制台/终端读入的,只能通过文件读入
	//绝大多数oj编译的时候,都会带一个编译选项 "-DONLINE_JUDGE",即定义一个名为ONLINE_JUDGE的宏
	//因此,把freopen用#ifndef ONLINE_JUDGE 和 #endif 包起来,oj的编译器就会自动忽略freopen
	//极少数oj是使用文件输入输出的。。如cogs,还有neycoj的部分题目。。要注意一下。。
	#ifndef ONLINE_JUDGE
	freopen("read.in","r",stdin);
	freopen("read.out","w",stdout);
	#endif
	int a,b;
	read(a);
	read(b);
	printf("%d",a+b);
	return 0;
}